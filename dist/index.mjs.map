{"version":3,"sources":["../src/errors.ts","../src/client.ts"],"names":[],"mappings":";AAKO,IAAM,WAAA,GAAN,cAA0B,KAAA,CAAM;AAAA;AAAA,EAE5B,MAAA;AAAA;AAAA,EAEA,IAAA;AAAA,EAET,WAAA,CAAY,OAAA,EAAiB,MAAA,EAAiB,IAAA,EAAe;AAC3D,IAAA,KAAA,CAAM,OAAO,CAAA;AACb,IAAA,IAAA,CAAK,IAAA,GAAO,aAAA;AACZ,IAAA,IAAA,CAAK,MAAA,GAAS,MAAA;AACd,IAAA,IAAA,CAAK,IAAA,GAAO,IAAA;AAEZ,IAAA,IAAI,MAAM,iBAAA,EAAmB;AAC3B,MAAA,KAAA,CAAM,iBAAA,CAAkB,IAAA,EAAM,IAAA,CAAK,WAAW,CAAA;AAAA,IAChD;AAAA,EACF;AACF;AAKO,IAAM,mBAAA,GAAN,cAAkC,WAAA,CAAY;AAAA,EACnD,WAAA,CAAY,UAAU,4BAAA,EAA8B;AAClD,IAAA,KAAA,CAAM,OAAA,EAAS,KAAK,sBAAsB,CAAA;AAC1C,IAAA,IAAA,CAAK,IAAA,GAAO,qBAAA;AAAA,EACd;AACF;AAKO,IAAM,cAAA,GAAN,cAA6B,WAAA,CAAY;AAAA;AAAA,EAErC,SAAA;AAAA,EAET,WAAA,CAAY,SAAiB,SAAA,EAA0B;AACrD,IAAA,KAAA,CAAM,OAAA,EAAS,KAAK,qBAAqB,CAAA;AACzC,IAAA,IAAA,CAAK,IAAA,GAAO,gBAAA;AACZ,IAAA,IAAA,CAAK,SAAA,GAAY,SAAA;AAAA,EACnB;AAAA;AAAA,EAGA,IAAI,UAAA,GAAqB;AACvB,IAAA,OAAO,IAAA,CAAK,IAAI,CAAA,EAAI,IAAA,CAAK,UAAU,KAAA,GAAQ,GAAA,GAAQ,IAAA,CAAK,GAAA,EAAK,CAAA;AAAA,EAC/D;AACF;AAKO,IAAM,eAAA,GAAN,cAA8B,WAAA,CAAY;AAAA;AAAA,EAEtC,MAAA;AAAA,EAET,WAAA,CAAY,SAAiB,MAAA,EAAmC;AAC9D,IAAA,KAAA,CAAM,OAAA,EAAS,KAAK,kBAAkB,CAAA;AACtC,IAAA,IAAA,CAAK,IAAA,GAAO,iBAAA;AACZ,IAAA,IAAA,CAAK,MAAA,GAAS,MAAA;AAAA,EAChB;AACF;AAKO,IAAM,aAAA,GAAN,cAA4B,WAAA,CAAY;AAAA,EAC7C,WAAA,CAAY,UAAU,oBAAA,EAAsB;AAC1C,IAAA,KAAA,CAAM,OAAA,EAAS,KAAK,WAAW,CAAA;AAC/B,IAAA,IAAA,CAAK,IAAA,GAAO,eAAA;AAAA,EACd;AACF;AAKO,IAAM,eAAA,GAAN,cAA8B,WAAA,CAAY;AAAA,EAC/C,WAAA,CAAY,SAAiB,IAAA,EAAe;AAC1C,IAAA,KAAA,CAAM,OAAA,EAAS,GAAA,EAAK,IAAA,IAAQ,mBAAmB,CAAA;AAC/C,IAAA,IAAA,CAAK,IAAA,GAAO,iBAAA;AAAA,EACd;AACF;AAKO,IAAM,YAAA,GAAN,cAA2B,WAAA,CAAY;AAAA,EAC5C,WAAA,CAAY,UAAU,mBAAA,EAAqB;AACzC,IAAA,KAAA,CAAM,OAAA,EAAS,QAAW,SAAS,CAAA;AACnC,IAAA,IAAA,CAAK,IAAA,GAAO,cAAA;AAAA,EACd;AACF;AAKO,IAAM,YAAA,GAAN,cAA2B,WAAA,CAAY;AAAA,EACnC,KAAA;AAAA,EAET,WAAA,CAAY,SAAiB,KAAA,EAAe;AAC1C,IAAA,KAAA,CAAM,OAAA,EAAS,QAAW,eAAe,CAAA;AACzC,IAAA,IAAA,CAAK,IAAA,GAAO,cAAA;AACZ,IAAA,IAAA,CAAK,KAAA,GAAQ,KAAA;AAAA,EACf;AACF;AAKO,IAAM,WAAA,GAAN,cAA0B,WAAA,CAAY;AAAA,EAC3C,WAAA,CAAY,OAAA,GAAU,uBAAA,EAAyB,MAAA,GAAS,GAAA,EAAK;AAC3D,IAAA,KAAA,CAAM,OAAA,EAAS,QAAQ,cAAc,CAAA;AACrC,IAAA,IAAA,CAAK,IAAA,GAAO,aAAA;AAAA,EACd;AACF;AAKO,SAAS,UAAA,CACd,MAAA,EACA,IAAA,EACA,SAAA,EACa;AACb,EAAA,MAAM,OAAA,GAAU,eAAe,IAAI,CAAA;AAEnC,EAAA,QAAQ,MAAA;AAAQ,IACd,KAAK,GAAA;AACH,MAAA,OAAO,IAAI,eAAA;AAAA,QACT,OAAA;AAAA,QACA,OAAO,SAAS,QAAA,IAAY,IAAA,KAAS,QAAQ,QAAA,IAAY,IAAA,GACpD,KAA8C,MAAA,GAC/C;AAAA,OACN;AAAA,IACF,KAAK,GAAA;AACH,MAAA,OAAO,IAAI,oBAAoB,OAAO,CAAA;AAAA,IACxC,KAAK,GAAA;AACH,MAAA,OAAO,IAAI,cAAc,OAAO,CAAA;AAAA,IAClC,KAAK,GAAA;AACH,MAAA,OAAO,IAAI,eAAA;AAAA,QACT,OAAA;AAAA,QACA,OAAO,IAAA,KAAS,QAAA,IAAY,IAAA,KAAS,IAAA,IAAQ,UAAU,IAAA,GACnD,MAAA,CAAQ,IAAA,CAA2B,IAAI,CAAA,GACvC;AAAA,OACN;AAAA,IACF,KAAK,GAAA;AACH,MAAA,OAAO,IAAI,cAAA;AAAA,QACT,OAAA;AAAA,QACA,SAAA,IAAa,EAAE,KAAA,EAAO,CAAA,EAAG,WAAW,CAAA,EAAG,KAAA,EAAO,IAAA,CAAK,KAAA,CAAM,IAAA,CAAK,GAAA,EAAI,GAAI,GAAI,IAAI,EAAA;AAAG,OACnF;AAAA,IACF;AACE,MAAA,IAAI,UAAU,GAAA,EAAK;AACjB,QAAA,OAAO,IAAI,WAAA,CAAY,OAAA,EAAS,MAAM,CAAA;AAAA,MACxC;AACA,MAAA,OAAO,IAAI,WAAA,CAAY,OAAA,EAAS,MAAM,CAAA;AAAA;AAE5C;AAEA,SAAS,eAAe,IAAA,EAAuB;AAC7C,EAAA,IAAI,OAAO,IAAA,KAAS,QAAA,EAAU,OAAO,IAAA;AACrC,EAAA,IAAI,OAAO,IAAA,KAAS,QAAA,IAAY,IAAA,KAAS,IAAA,EAAM;AAC7C,IAAA,IAAI,SAAA,IAAa,IAAA,IAAQ,OAAQ,IAAA,CAA8B,YAAY,QAAA,EAAU;AACnF,MAAA,OAAQ,IAAA,CAA6B,OAAA;AAAA,IACvC;AACA,IAAA,IAAI,OAAA,IAAW,IAAA,IAAQ,OAAQ,IAAA,CAA4B,UAAU,QAAA,EAAU;AAC7E,MAAA,OAAQ,IAAA,CAA2B,KAAA;AAAA,IACrC;AAAA,EACF;AACA,EAAA,OAAO,eAAA;AACT;;;AC3JA,IAAM,gBAAA,GAAmB,wBAAA;AACzB,IAAM,eAAA,GAAkB,GAAA;AACxB,IAAM,eAAA,GAAkB,CAAA;AACxB,IAAM,mBAAA,GAAsB,GAAA;AAG5B,IAAM,sBAAA,mBAAyB,IAAI,GAAA,CAAI,CAAC,GAAA,EAAK,KAAK,GAAA,EAAK,GAAA,EAAK,GAAA,EAAK,GAAG,CAAC,CAAA;AAiB9D,IAAM,SAAN,MAAa;AAAA,EACD,MAAA;AAAA,EACA,OAAA;AAAA,EACA,OAAA;AAAA,EACA,OAAA;AAAA,EACA,UAAA;AAAA,EACA,OAAA;AAAA;AAAA,EAGV,aAAA;AAAA,EAEP,YAAY,cAAA,EAAuC;AACjD,IAAA,MAAM,SACJ,OAAO,cAAA,KAAmB,WACtB,EAAE,MAAA,EAAQ,gBAAe,GACzB,cAAA;AAEN,IAAA,IAAI,CAAC,OAAO,MAAA,EAAQ;AAClB,MAAA,MAAM,IAAI,YAAY,qBAAqB,CAAA;AAAA,IAC7C;AAEA,IAAA,IAAA,CAAK,SAAS,MAAA,CAAO,MAAA;AACrB,IAAA,IAAA,CAAK,WAAW,MAAA,CAAO,OAAA,IAAW,gBAAA,EAAkB,OAAA,CAAQ,OAAO,EAAE,CAAA;AACrE,IAAA,IAAA,CAAK,OAAA,GAAU,OAAO,OAAA,IAAW,eAAA;AACjC,IAAA,IAAA,CAAK,OAAA,GAAU,OAAO,OAAA,IAAW,eAAA;AACjC,IAAA,IAAA,CAAK,UAAA,GAAa,OAAO,UAAA,IAAc,mBAAA;AACvC,IAAA,IAAA,CAAK,OAAA,GAAU,MAAA,CAAO,KAAA,IAAS,UAAA,CAAW,KAAA;AAE1C,IAAA,IAAI,CAAC,KAAK,OAAA,EAAS;AACjB,MAAA,MAAM,IAAI,WAAA;AAAA,QACR;AAAA,OACF;AAAA,IACF;AAAA,EACF;AAAA,EA2BA,MAAM,WACJ,OAAA,EAC0C;AAC1C,IAAA,MAAM,EAAE,KAAA,EAAO,GAAG,IAAA,EAAK,GAAI,OAAA;AAE3B,IAAA,IAAI,KAAA,EAAO;AACT,MAAA,OAAO,KAAK,OAAA,CAAgC;AAAA,QAC1C,MAAA,EAAQ,MAAA;AAAA,QACR,IAAA,EAAM,gBAAA;AAAA,QACN,IAAA,EAAM,EAAE,GAAG,IAAA,EAAM,OAAO,IAAA,EAAK;AAAA,QAC7B,YAAA,EAAc;AAAA,OACf,CAAA;AAAA,IACH;AAEA,IAAA,OAAO,KAAK,OAAA,CAAgB;AAAA,MAC1B,MAAA,EAAQ,MAAA;AAAA,MACR,IAAA,EAAM,gBAAA;AAAA,MACN,IAAA,EAAM,EAAE,GAAG,IAAA,EAAM,OAAO,KAAA,EAAM;AAAA,MAC9B,YAAA,EAAc;AAAA,KACf,CAAA;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,MAAM,KAAA,GAA8B;AAClC,IAAA,OAAO,KAAK,OAAA,CAAqB;AAAA,MAC/B,MAAA,EAAQ,KAAA;AAAA,MACR,IAAA,EAAM,WAAA;AAAA,MACN,YAAA,EAAc;AAAA,KACf,CAAA;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,MAAA,GAAgC;AACpC,IAAA,OAAO,KAAK,OAAA,CAAsB;AAAA,MAChC,MAAA,EAAQ,KAAA;AAAA,MACR,IAAA,EAAM,SAAA;AAAA,MACN,YAAA,EAAc;AAAA,KACf,CAAA;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,QAAW,OAAA,EAAqC;AAC5D,IAAA,MAAM,EAAE,MAAA,EAAQ,IAAA,EAAM,IAAA,EAAM,YAAA,GAAe,QAAO,GAAI,OAAA;AACtD,IAAA,MAAM,GAAA,GAAM,CAAA,EAAG,IAAA,CAAK,OAAO,GAAG,IAAI,CAAA,CAAA;AAElC,IAAA,MAAM,OAAA,GAAkC;AAAA,MACtC,aAAA,EAAe,CAAA,OAAA,EAAU,IAAA,CAAK,MAAM,CAAA,CAAA;AAAA,MACpC,MAAA,EAAQ,YAAA,KAAiB,MAAA,GAAS,kBAAA,GAAqB;AAAA,KACzD;AAEA,IAAA,IAAI,IAAA,EAAM;AACR,MAAA,OAAA,CAAQ,cAAc,CAAA,GAAI,kBAAA;AAAA,IAC5B;AAEA,IAAA,IAAI,SAAA;AAEJ,IAAA,KAAA,IAAS,OAAA,GAAU,CAAA,EAAG,OAAA,IAAW,IAAA,CAAK,SAAS,OAAA,EAAA,EAAW;AACxD,MAAA,IAAI;AACF,QAAA,MAAM,QAAA,GAAW,MAAM,IAAA,CAAK,gBAAA,CAAiB,GAAA,EAAK;AAAA,UAChD,MAAA;AAAA,UACA,OAAA;AAAA,UACA,IAAA,EAAM,IAAA,GAAO,IAAA,CAAK,SAAA,CAAU,IAAI,CAAA,GAAI,KAAA;AAAA,SACrC,CAAA;AAGD,QAAA,IAAA,CAAK,aAAA,GAAgB,IAAA,CAAK,qBAAA,CAAsB,QAAA,CAAS,OAAO,CAAA;AAEhE,QAAA,IAAI,CAAC,SAAS,EAAA,EAAI;AAChB,UAAA,IAAI,SAAA;AACJ,UAAA,IAAI;AACF,YAAA,SAAA,GAAY,MAAM,SAAS,IAAA,EAAK;AAAA,UAClC,CAAA,CAAA,MAAQ;AACN,YAAA,SAAA,GAAY,MAAM,QAAA,CAAS,IAAA,EAAK,CAAE,KAAA,CAAM,MAAM,IAAI,CAAA;AAAA,UACpD;AAEA,UAAA,MAAM,QAAQ,UAAA,CAAW,QAAA,CAAS,MAAA,EAAQ,SAAA,EAAW,KAAK,aAAa,CAAA;AAGvE,UAAA,IAAI,uBAAuB,GAAA,CAAI,QAAA,CAAS,MAAM,CAAA,IAAK,OAAA,GAAU,KAAK,OAAA,EAAS;AACzE,YAAA,SAAA,GAAY,KAAA;AACZ,YAAA,MAAM,IAAA,CAAK,MAAM,IAAA,CAAK,gBAAA,CAAiB,SAAS,QAAA,CAAS,MAAA,KAAW,GAAG,CAAC,CAAA;AACxE,YAAA;AAAA,UACF;AAEA,UAAA,MAAM,KAAA;AAAA,QACR;AAGA,QAAA,IAAI,iBAAiB,QAAA,EAAU;AAC7B,UAAA,MAAM,WAAA,GAAc,MAAM,QAAA,CAAS,WAAA,EAAY;AAC/C,UAAA,OAAO,MAAA,CAAO,KAAK,WAAW,CAAA;AAAA,QAChC;AAEA,QAAA,OAAQ,MAAM,SAAS,IAAA,EAAK;AAAA,MAC9B,SAAS,KAAA,EAAO;AAEd,QAAA,IAAI,KAAA,YAAiB,eAAe,CAAC,sBAAA,CAAuB,IAAI,KAAA,CAAM,MAAA,IAAU,CAAC,CAAA,EAAG;AAClF,UAAA,MAAM,KAAA;AAAA,QACR;AAEA,QAAA,IAAI,KAAA,YAAiB,YAAA,IAAgB,KAAA,YAAiB,YAAA,EAAc;AAClE,UAAA,IAAI,OAAA,GAAU,KAAK,OAAA,EAAS;AAC1B,YAAA,SAAA,GAAY,KAAA;AACZ,YAAA,MAAM,KAAK,KAAA,CAAM,IAAA,CAAK,gBAAA,CAAiB,OAAA,EAAS,KAAK,CAAC,CAAA;AACtD,YAAA;AAAA,UACF;AAAA,QACF;AAGA,QAAA,IAAI,iBAAiB,WAAA,EAAa;AAChC,UAAA,MAAM,KAAA;AAAA,QACR;AAGA,QAAA,IAAI,iBAAiB,KAAA,EAAO;AAC1B,UAAA,IAAI,KAAA,CAAM,SAAS,YAAA,EAAc;AAC/B,YAAA,MAAM,IAAI,YAAA,CAAa,CAAA,wBAAA,EAA2B,IAAA,CAAK,OAAO,CAAA,EAAA,CAAI,CAAA;AAAA,UACpE;AACA,UAAA,MAAM,IAAI,YAAA,CAAa,CAAA,eAAA,EAAkB,KAAA,CAAM,OAAO,IAAI,KAAK,CAAA;AAAA,QACjE;AAEA,QAAA,MAAM,IAAI,WAAA,CAAY,CAAA,eAAA,EAAkB,MAAA,CAAO,KAAK,CAAC,CAAA,CAAE,CAAA;AAAA,MACzD;AAAA,IACF;AAGA,IAAA,MAAM,SAAA,IAAa,IAAI,WAAA,CAAY,8BAA8B,CAAA;AAAA,EACnE;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,gBAAA,CACZ,GAAA,EACA,IAAA,EACmB;AACnB,IAAA,MAAM,UAAA,GAAa,IAAI,eAAA,EAAgB;AACvC,IAAA,MAAM,YAAY,UAAA,CAAW,MAAM,WAAW,KAAA,EAAM,EAAG,KAAK,OAAO,CAAA;AAEnE,IAAA,IAAI;AACF,MAAA,OAAO,MAAM,IAAA,CAAK,OAAA,CAAQ,GAAA,EAAK;AAAA,QAC7B,GAAG,IAAA;AAAA,QACH,QAAQ,UAAA,CAAW;AAAA,OACpB,CAAA;AAAA,IACH,SAAS,KAAA,EAAO;AACd,MAAA,IAAI,KAAA,YAAiB,KAAA,IAAS,KAAA,CAAM,IAAA,KAAS,YAAA,EAAc;AACzD,QAAA,MAAM,IAAI,YAAA,CAAa,CAAA,wBAAA,EAA2B,IAAA,CAAK,OAAO,CAAA,EAAA,CAAI,CAAA;AAAA,MACpE;AACA,MAAA,MAAM,IAAI,YAAA;AAAA,QACR,kBAAkB,KAAA,YAAiB,KAAA,GAAQ,MAAM,OAAA,GAAU,MAAA,CAAO,KAAK,CAAC,CAAA,CAAA;AAAA,QACxE,KAAA,YAAiB,QAAQ,KAAA,GAAQ;AAAA,OACnC;AAAA,IACF,CAAA,SAAE;AACA,MAAA,YAAA,CAAa,SAAS,CAAA;AAAA,IACxB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,sBAAsB,OAAA,EAA6C;AACzE,IAAA,MAAM,KAAA,GAAQ,OAAA,CAAQ,GAAA,CAAI,mBAAmB,CAAA;AAC7C,IAAA,MAAM,SAAA,GAAY,OAAA,CAAQ,GAAA,CAAI,uBAAuB,CAAA;AACrD,IAAA,MAAM,KAAA,GAAQ,OAAA,CAAQ,GAAA,CAAI,mBAAmB,CAAA;AAE7C,IAAA,IAAI,KAAA,IAAS,aAAa,KAAA,EAAO;AAC/B,MAAA,OAAO;AAAA,QACL,KAAA,EAAO,QAAA,CAAS,KAAA,EAAO,EAAE,CAAA;AAAA,QACzB,SAAA,EAAW,QAAA,CAAS,SAAA,EAAW,EAAE,CAAA;AAAA,QACjC,KAAA,EAAO,QAAA,CAAS,KAAA,EAAO,EAAE;AAAA,OAC3B;AAAA,IACF;AAEA,IAAA,OAAO,MAAA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKQ,gBAAA,CAAiB,SAAiB,WAAA,EAA8B;AACtE,IAAA,IAAI,WAAA,IAAe,KAAK,aAAA,EAAe;AAErC,MAAA,MAAM,aAAc,IAAA,CAAK,aAAA,CAAc,KAAA,GAAQ,GAAA,GAAQ,KAAK,GAAA,EAAI;AAChE,MAAA,OAAO,KAAK,GAAA,CAAI,GAAA,EAAM,KAAK,GAAA,CAAI,UAAA,EAAY,GAAK,CAAC,CAAA;AAAA,IACnD;AAGA,IAAA,MAAM,YAAY,IAAA,CAAK,UAAA,GAAa,IAAA,CAAK,GAAA,CAAI,GAAG,OAAO,CAAA;AACvD,IAAA,MAAM,MAAA,GAAS,IAAA,CAAK,MAAA,EAAO,GAAI,GAAA,GAAM,SAAA;AACrC,IAAA,OAAO,IAAA,CAAK,GAAA,CAAI,SAAA,GAAY,MAAA,EAAQ,GAAK,CAAA;AAAA,EAC3C;AAAA;AAAA;AAAA;AAAA,EAKQ,MAAM,EAAA,EAA2B;AACvC,IAAA,OAAO,IAAI,OAAA,CAAQ,CAAC,YAAY,UAAA,CAAW,OAAA,EAAS,EAAE,CAAC,CAAA;AAAA,EACzD;AACF","file":"index.mjs","sourcesContent":["import type { RateLimitInfo } from './types.js';\n\n/**\n * Base error class for all Pxshot errors\n */\nexport class PxshotError extends Error {\n  /** HTTP status code (if applicable) */\n  readonly status?: number;\n  /** Error code from API */\n  readonly code?: string;\n\n  constructor(message: string, status?: number, code?: string) {\n    super(message);\n    this.name = 'PxshotError';\n    this.status = status;\n    this.code = code;\n    // Maintains proper stack trace in V8\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n}\n\n/**\n * Authentication error (401)\n */\nexport class AuthenticationError extends PxshotError {\n  constructor(message = 'Invalid or missing API key') {\n    super(message, 401, 'authentication_error');\n    this.name = 'AuthenticationError';\n  }\n}\n\n/**\n * Rate limit exceeded error (429)\n */\nexport class RateLimitError extends PxshotError {\n  /** Rate limit information */\n  readonly rateLimit: RateLimitInfo;\n\n  constructor(message: string, rateLimit: RateLimitInfo) {\n    super(message, 429, 'rate_limit_exceeded');\n    this.name = 'RateLimitError';\n    this.rateLimit = rateLimit;\n  }\n\n  /** Milliseconds until the rate limit resets */\n  get retryAfter(): number {\n    return Math.max(0, (this.rateLimit.reset * 1000) - Date.now());\n  }\n}\n\n/**\n * Validation error (400)\n */\nexport class ValidationError extends PxshotError {\n  /** Field-level validation errors */\n  readonly errors?: Record<string, string[]>;\n\n  constructor(message: string, errors?: Record<string, string[]>) {\n    super(message, 400, 'validation_error');\n    this.name = 'ValidationError';\n    this.errors = errors;\n  }\n}\n\n/**\n * Resource not found error (404)\n */\nexport class NotFoundError extends PxshotError {\n  constructor(message = 'Resource not found') {\n    super(message, 404, 'not_found');\n    this.name = 'NotFoundError';\n  }\n}\n\n/**\n * Screenshot capture failed error\n */\nexport class ScreenshotError extends PxshotError {\n  constructor(message: string, code?: string) {\n    super(message, 422, code ?? 'screenshot_failed');\n    this.name = 'ScreenshotError';\n  }\n}\n\n/**\n * Timeout error\n */\nexport class TimeoutError extends PxshotError {\n  constructor(message = 'Request timed out') {\n    super(message, undefined, 'timeout');\n    this.name = 'TimeoutError';\n  }\n}\n\n/**\n * Network/connection error\n */\nexport class NetworkError extends PxshotError {\n  readonly cause?: Error;\n\n  constructor(message: string, cause?: Error) {\n    super(message, undefined, 'network_error');\n    this.name = 'NetworkError';\n    this.cause = cause;\n  }\n}\n\n/**\n * Server error (5xx)\n */\nexport class ServerError extends PxshotError {\n  constructor(message = 'Internal server error', status = 500) {\n    super(message, status, 'server_error');\n    this.name = 'ServerError';\n  }\n}\n\n/**\n * Parse an API error response into the appropriate error class\n */\nexport function parseError(\n  status: number,\n  body: unknown,\n  rateLimit?: RateLimitInfo\n): PxshotError {\n  const message = extractMessage(body);\n\n  switch (status) {\n    case 400:\n      return new ValidationError(\n        message,\n        typeof body === 'object' && body !== null && 'errors' in body\n          ? (body as { errors: Record<string, string[]> }).errors\n          : undefined\n      );\n    case 401:\n      return new AuthenticationError(message);\n    case 404:\n      return new NotFoundError(message);\n    case 422:\n      return new ScreenshotError(\n        message,\n        typeof body === 'object' && body !== null && 'code' in body\n          ? String((body as { code: unknown }).code)\n          : undefined\n      );\n    case 429:\n      return new RateLimitError(\n        message,\n        rateLimit ?? { limit: 0, remaining: 0, reset: Math.floor(Date.now() / 1000) + 60 }\n      );\n    default:\n      if (status >= 500) {\n        return new ServerError(message, status);\n      }\n      return new PxshotError(message, status);\n  }\n}\n\nfunction extractMessage(body: unknown): string {\n  if (typeof body === 'string') return body;\n  if (typeof body === 'object' && body !== null) {\n    if ('message' in body && typeof (body as { message: unknown }).message === 'string') {\n      return (body as { message: string }).message;\n    }\n    if ('error' in body && typeof (body as { error: unknown }).error === 'string') {\n      return (body as { error: string }).error;\n    }\n  }\n  return 'Unknown error';\n}\n","import type {\n  PxshotConfig,\n  ScreenshotOptions,\n  ScreenshotOptionsStore,\n  ScreenshotStoredResult,\n  UsageResult,\n  HealthResult,\n  RateLimitInfo,\n  RequestOptions,\n} from './types.js';\nimport {\n  PxshotError,\n  NetworkError,\n  TimeoutError,\n  parseError,\n} from './errors.js';\n\nconst DEFAULT_BASE_URL = 'https://api.pxshot.com';\nconst DEFAULT_TIMEOUT = 60000; // 60 seconds\nconst DEFAULT_RETRIES = 2;\nconst DEFAULT_RETRY_DELAY = 1000;\n\n// Status codes that are safe to retry\nconst RETRYABLE_STATUS_CODES = new Set([408, 429, 500, 502, 503, 504]);\n\n/**\n * Pxshot API client\n *\n * @example\n * ```typescript\n * const client = new Pxshot('px_your_api_key');\n *\n * // Get screenshot as buffer\n * const buffer = await client.screenshot({ url: 'https://example.com' });\n *\n * // Get screenshot URL\n * const result = await client.screenshot({ url: 'https://example.com', store: true });\n * console.log(result.url);\n * ```\n */\nexport class Pxshot {\n  private readonly apiKey: string;\n  private readonly baseUrl: string;\n  private readonly timeout: number;\n  private readonly retries: number;\n  private readonly retryDelay: number;\n  private readonly fetchFn: typeof fetch;\n\n  /** Last rate limit info from the most recent request */\n  public lastRateLimit?: RateLimitInfo;\n\n  constructor(apiKeyOrConfig: string | PxshotConfig) {\n    const config: PxshotConfig =\n      typeof apiKeyOrConfig === 'string'\n        ? { apiKey: apiKeyOrConfig }\n        : apiKeyOrConfig;\n\n    if (!config.apiKey) {\n      throw new PxshotError('API key is required');\n    }\n\n    this.apiKey = config.apiKey;\n    this.baseUrl = (config.baseUrl ?? DEFAULT_BASE_URL).replace(/\\/$/, '');\n    this.timeout = config.timeout ?? DEFAULT_TIMEOUT;\n    this.retries = config.retries ?? DEFAULT_RETRIES;\n    this.retryDelay = config.retryDelay ?? DEFAULT_RETRY_DELAY;\n    this.fetchFn = config.fetch ?? globalThis.fetch;\n\n    if (!this.fetchFn) {\n      throw new PxshotError(\n        'fetch is not available. Please provide a fetch implementation in the config.'\n      );\n    }\n  }\n\n  /**\n   * Capture a screenshot\n   *\n   * @param options - Screenshot options\n   * @returns Buffer when store=false (default), or ScreenshotStoredResult when store=true\n   *\n   * @example\n   * ```typescript\n   * // Get as buffer\n   * const buffer = await client.screenshot({ url: 'https://example.com' });\n   * fs.writeFileSync('screenshot.png', buffer);\n   *\n   * // Get as URL\n   * const result = await client.screenshot({\n   *   url: 'https://example.com',\n   *   store: true,\n   *   format: 'webp',\n   *   width: 1280,\n   *   height: 720,\n   * });\n   * console.log(result.url);\n   * ```\n   */\n  async screenshot(options: ScreenshotOptionsStore): Promise<ScreenshotStoredResult>;\n  async screenshot(options: ScreenshotOptions): Promise<Buffer>;\n  async screenshot(\n    options: ScreenshotOptions\n  ): Promise<Buffer | ScreenshotStoredResult> {\n    const { store, ...rest } = options;\n\n    if (store) {\n      return this.request<ScreenshotStoredResult>({\n        method: 'POST',\n        path: '/v1/screenshot',\n        body: { ...rest, store: true },\n        responseType: 'json',\n      });\n    }\n\n    return this.request<Buffer>({\n      method: 'POST',\n      path: '/v1/screenshot',\n      body: { ...rest, store: false },\n      responseType: 'buffer',\n    });\n  }\n\n  /**\n   * Get usage statistics for the current billing period\n   *\n   * @returns Current usage information\n   *\n   * @example\n   * ```typescript\n   * const usage = await client.usage();\n   * console.log(`Used ${usage.screenshots_used} of ${usage.screenshots_limit} screenshots`);\n   * ```\n   */\n  async usage(): Promise<UsageResult> {\n    return this.request<UsageResult>({\n      method: 'GET',\n      path: '/v1/usage',\n      responseType: 'json',\n    });\n  }\n\n  /**\n   * Check API health status\n   *\n   * @returns Health status\n   */\n  async health(): Promise<HealthResult> {\n    return this.request<HealthResult>({\n      method: 'GET',\n      path: '/health',\n      responseType: 'json',\n    });\n  }\n\n  /**\n   * Make an authenticated request to the API\n   */\n  private async request<T>(options: RequestOptions): Promise<T> {\n    const { method, path, body, responseType = 'json' } = options;\n    const url = `${this.baseUrl}${path}`;\n\n    const headers: Record<string, string> = {\n      Authorization: `Bearer ${this.apiKey}`,\n      Accept: responseType === 'json' ? 'application/json' : '*/*',\n    };\n\n    if (body) {\n      headers['Content-Type'] = 'application/json';\n    }\n\n    let lastError: Error | undefined;\n\n    for (let attempt = 0; attempt <= this.retries; attempt++) {\n      try {\n        const response = await this.fetchWithTimeout(url, {\n          method,\n          headers,\n          body: body ? JSON.stringify(body) : undefined,\n        });\n\n        // Parse rate limit headers\n        this.lastRateLimit = this.parseRateLimitHeaders(response.headers);\n\n        if (!response.ok) {\n          let errorBody: unknown;\n          try {\n            errorBody = await response.json();\n          } catch {\n            errorBody = await response.text().catch(() => null);\n          }\n\n          const error = parseError(response.status, errorBody, this.lastRateLimit);\n\n          // Only retry on specific status codes\n          if (RETRYABLE_STATUS_CODES.has(response.status) && attempt < this.retries) {\n            lastError = error;\n            await this.sleep(this.calculateBackoff(attempt, response.status === 429));\n            continue;\n          }\n\n          throw error;\n        }\n\n        // Parse response based on expected type\n        if (responseType === 'buffer') {\n          const arrayBuffer = await response.arrayBuffer();\n          return Buffer.from(arrayBuffer) as T;\n        }\n\n        return (await response.json()) as T;\n      } catch (error) {\n        // Don't retry on non-retryable errors\n        if (error instanceof PxshotError && !RETRYABLE_STATUS_CODES.has(error.status ?? 0)) {\n          throw error;\n        }\n\n        if (error instanceof TimeoutError || error instanceof NetworkError) {\n          if (attempt < this.retries) {\n            lastError = error;\n            await this.sleep(this.calculateBackoff(attempt, false));\n            continue;\n          }\n        }\n\n        // If it's already one of our errors, rethrow\n        if (error instanceof PxshotError) {\n          throw error;\n        }\n\n        // Wrap unknown errors\n        if (error instanceof Error) {\n          if (error.name === 'AbortError') {\n            throw new TimeoutError(`Request timed out after ${this.timeout}ms`);\n          }\n          throw new NetworkError(`Network error: ${error.message}`, error);\n        }\n\n        throw new PxshotError(`Unknown error: ${String(error)}`);\n      }\n    }\n\n    // If we exhausted retries, throw the last error\n    throw lastError ?? new PxshotError('Request failed after retries');\n  }\n\n  /**\n   * Fetch with timeout support\n   */\n  private async fetchWithTimeout(\n    url: string,\n    init: RequestInit\n  ): Promise<Response> {\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), this.timeout);\n\n    try {\n      return await this.fetchFn(url, {\n        ...init,\n        signal: controller.signal,\n      });\n    } catch (error) {\n      if (error instanceof Error && error.name === 'AbortError') {\n        throw new TimeoutError(`Request timed out after ${this.timeout}ms`);\n      }\n      throw new NetworkError(\n        `Network error: ${error instanceof Error ? error.message : String(error)}`,\n        error instanceof Error ? error : undefined\n      );\n    } finally {\n      clearTimeout(timeoutId);\n    }\n  }\n\n  /**\n   * Parse rate limit headers from response\n   */\n  private parseRateLimitHeaders(headers: Headers): RateLimitInfo | undefined {\n    const limit = headers.get('X-RateLimit-Limit');\n    const remaining = headers.get('X-RateLimit-Remaining');\n    const reset = headers.get('X-RateLimit-Reset');\n\n    if (limit && remaining && reset) {\n      return {\n        limit: parseInt(limit, 10),\n        remaining: parseInt(remaining, 10),\n        reset: parseInt(reset, 10),\n      };\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Calculate exponential backoff delay\n   */\n  private calculateBackoff(attempt: number, isRateLimit: boolean): number {\n    if (isRateLimit && this.lastRateLimit) {\n      // For rate limits, wait until reset\n      const retryAfter = (this.lastRateLimit.reset * 1000) - Date.now();\n      return Math.max(1000, Math.min(retryAfter, 60000));\n    }\n\n    // Exponential backoff with jitter\n    const baseDelay = this.retryDelay * Math.pow(2, attempt);\n    const jitter = Math.random() * 0.3 * baseDelay;\n    return Math.min(baseDelay + jitter, 30000);\n  }\n\n  /**\n   * Sleep for specified milliseconds\n   */\n  private sleep(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n}\n"]}